<h1>3111번 문제</h1>

김상근은 창영마을에서의 권력을 유지하기 위해 신문을 검열하려고 한다.

상근이는 텍스트 T에서 A라는 단어를 다음과 같은 알고리즘을 이용해서 모두 없애려고 한다.

1. T에 A가 없으면 알고리즘을 종료한다.

2. T에서 처음 등장하는 A를 찾은 뒤, 삭제한다.

3. T에 A가 없으면 알고리즘을 종료한다.

4. T에서 마지막으로 등장하는 A를 찾은 뒤, 삭제한다.

5. 1번으로 돌아간다.


상근이는 마을을 지배해야하기 때문에, 검열을 할 시간이 없다. 상근이의 검열을 대신해주는 프로그램을 작성하시오. 


Input : 첫첫째 줄에 단어 A가, 둘째 줄에 텍스트 T가 주어진다. A와 T는 알파벳 소문자로만 이루어져 있고, A는 최대 25자, T는 최대 300,000자이다.


Output : 검열을 한 이후의 텍스트를 출력한다.

조건 : 시간 제한 1.5초, 메모리 제한 128MB

---

사용한 알고리즘 : Stack

사용한 메모리 : 

걸린 시간 :

사용한 언어 : JavaScript

코드 길이 : 2893 B

---

<h3>느낀 점</h3>

 해당 문제에는 특이한 알고리즘이 있는데, 스택에 넣으면서 문자열이 존재하는지 확인을 하는 것이 아니라, 양쪽 끝에서 가까운 문자열부터 존재하는지 확인한 후 삭제하는 것이다.
 따라서 leftStack과 rightStack의 두 개의 스택으로 나누어 turn을 주고받으며 스택에 입력받는 식으로 구현해야겠다는 생각이 들었고, 양쪽 끝과 가까운 문자열을 찾기 위해서는 leftStack에서는 문제가 없으나, rightStack에서는 문자열을 역순의 형태로 넣어야한다고 생각했다.
 스택을 역순으로 넣는 과정에서 slice()로 금지어 길이 만큼 잘라내어 비교를 하는 방식으로 구현을 했는데, leftStack과 rightStack을 merge하는 과정에서 새로운 금지어가 중간에서 만들어져 검열이 안되는 오류가 있었다. 
 이를 해결하기 위해 문제에 나온 알고리즘과는 별개로 추가적으로 선형적으로 문자열을 검사하는 censorLinear()을 생성하였고, 금지어가 존재하여 삭제를 하는 경우에는 문자열 검사를 계속 반복하도록 구현하여 해결하였다.
